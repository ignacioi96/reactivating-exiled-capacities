{{ define "main" }}
</div> <!-- Close the container from baseof.html -->

<div class="clusters-layout">
    <aside class="clusters-sidebar">
        <div class="container">
            <h2>Clusters</h2>
            <ul class="cluster-list" id="cluster-list">
                <li style="color: #cbd5e1; padding: 20px; text-align: center;">Loading clusters...</li>
            </ul>
        </div>
    </aside>

    <div class="content-area">
        <div class="thumbnails-container" id="thumbnails-container">
            <div style="color: #cbd5e1; padding: 50px; text-align: center; font-size: 1.2rem;">Loading visualization...</div>
        </div>
    </div>
</div>

<div class="container"> <!-- Re-open container for any following content -->

<!-- Cluster Visualization Modal -->
<div class="cluster-modal" id="cluster-modal">
    <div class="modal-content">
        <button class="close-modal" id="close-modal">&times;</button>
        
        <div class="modal-header" id="modal-header">
            <h2 class="modal-title" id="modal-title"></h2>
            <p class="modal-description" id="modal-description"></p>
            <div class="why-matters" id="why-matters"></div>
        </div>
        
        <div class="network-container">
            <svg class="network-svg" id="network-svg"></svg>
        </div>
    </div>
    
    <!-- Capacity Detail Panel -->
    <div class="capacity-detail" id="capacity-detail">
        <button class="close-detail" id="close-detail">&times;</button>
        <h3 id="capacity-title"></h3>
        <p class="subtitle" id="capacity-subtitle"></p>
        <div class="detail-section">
            <h4>What it is</h4>
            <div id="capacity-what-it-is"></div>
        </div>
        <div class="detail-section">
            <h4>Why it's been exiled</h4>
            <div id="capacity-why-exiled"></div>
        </div>
        <div class="detail-section">
            <h4>What it makes possible</h4>
            <div id="capacity-what-possible"></div>
        </div>
        <div class="detail-section">
            <h4>Distortions</h4>
            <ul class="distortions-list" id="capacity-distortions"></ul>
        </div>
    </div>
</div>

<!-- Embedded Cluster Data -->
<script id="clusters-data" type="application/json">
    {{- $clusters := where .Site.Pages "Type" "clusters" -}}
    {{- $clusters := where $clusters "Kind" "!=" "section" -}}
    {{- $defaultColor := "rgb(139, 92, 246)" -}}
    [
    {{- range $i, $cluster := $clusters -}}
      {
        "title": {{ $cluster.Title | jsonify }},
        "description": {{ $cluster.Params.description | default "" | jsonify }},
        "why_matters": {{ $cluster.Params.why_matters | default "" | jsonify }},
        "image": {{ if $cluster.Params.image }}{{ $cluster.Params.image | jsonify }}{{ else }}""{{ end }},
        "position_x": {{ $cluster.Params.position_x | default 0 }},
        "position_y": {{ $cluster.Params.position_y | default 0 }},
        "capacities": [
          {{- range $j, $capacity := $cluster.Params.capacities -}}
          {
            "title": {{ $capacity.title | default "" | jsonify }},
            "subtitle": {{ $capacity.subtitle | default "" | jsonify }},
            "what_it_is": {{ $capacity.what_it_is | default "" | jsonify }},
            "why_exiled": {{ $capacity.why_exiled | default "" | jsonify }},
            "what_possible": {{ $capacity.what_possible | default "" | jsonify }},
            "distortions": [
              {{- range $k, $distortion := $capacity.distortions -}}
              {
                "name": {{ $distortion.name | default "" | jsonify }},
                "description": {{ $distortion.description | default "" | jsonify }}
              }{{- if ne $k (sub (len $capacity.distortions) 1) -}},{{- end -}}
              {{- end -}}
            ],
            "color": {{ $capacity.color | default $defaultColor | jsonify }},
            "position_x": {{ $capacity.position_x | default 0 }},
            "position_y": {{ $capacity.position_y | default 0 }}
          }{{- if ne $j (sub (len $cluster.Params.capacities) 1) -}},{{- end -}}
          {{- end -}}
        ]
      }{{- if ne $i (sub (len $clusters) 1) -}},{{- end -}}
    {{- end -}}
    ]
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>

<script>
    let clustersData = [];

    try {
        const dataScript = document.getElementById('clusters-data');
        if (dataScript && dataScript.textContent) {
            clustersData = JSON.parse(dataScript.textContent);
            clustersData = clustersData.map(cluster => {
                if (cluster.image && typeof cluster.image === 'string') {
                    cluster.image = cluster.image.replace(/^["']|["']$/g, '');
                    cluster.image = decodeURIComponent(cluster.image);
                    cluster.image = cluster.image.replace(/['"]/g, '');
                }
                return cluster;
            });
        }
    } catch (error) {
        console.error('Error parsing cluster data:', error);
    }

    class CapacitiesVisualization {
        constructor() {
            this.currentCluster = null;
            this.svg = d3.select('#network-svg');
            this.width = 0;
            this.height = 0;
            this.simulation = null;
            this.physicsObjects = [];
            this.animationRunning = false;
            this.containerBounds = {};
            this.init();
        }

        init() {
            if (clustersData.length === 0) {
                this.showNoDataMessage();
                return;
            }
            this.populateClusterList();
            this.createFloatingThumbnails();
            this.setupEventListeners();
            this.startFloatingAnimation();
            this.updateLayoutHeight();
            window.addEventListener('resize', () => this.updateLayoutHeight());
        }

        updateLayoutHeight() {
            const header = document.querySelector('header');
            const footer = document.querySelector('footer');
            const layout = document.querySelector('.clusters-layout');
            
            if (!layout || window.innerWidth <= 768) return;
            
            const headerHeight = header ? header.offsetHeight : 0;
            const footerHeight = footer ? footer.offsetHeight : 0;
            const availableHeight = window.innerHeight - headerHeight - footerHeight;
            
            layout.style.height = availableHeight + 'px';
            layout.style.maxHeight = availableHeight + 'px';
        }

        showNoDataMessage() {
            const clusterList = document.getElementById('cluster-list');
            clusterList.innerHTML = '<li style="color: #cbd5e1; padding: 20px; text-align: center;">No clusters found</li>';
            const container = document.getElementById('thumbnails-container');
            container.innerHTML = '<div style="color: #cbd5e1; padding: 50px; text-align: center;">Add cluster content files</div>';
        }

        populateClusterList() {
            const clusterList = document.getElementById('cluster-list');
            clusterList.innerHTML = '';
            clustersData.forEach((cluster, index) => {
                const li = document.createElement('li');
                li.className = 'cluster-item';
                const link = document.createElement('a');
                link.className = 'cluster-link';
                link.href = '#';
                link.innerHTML = `
                    <div class="cluster-title">${cluster.title}</div>
                    <div class="cluster-description">${cluster.description}</div>
                `;
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    this.openClusterModal(index);
                });
                li.appendChild(link);
                clusterList.appendChild(li);
            });
        }

        createFloatingThumbnails() {
            const container = document.getElementById('thumbnails-container');
            container.innerHTML = '';
            const containerRect = container.getBoundingClientRect();
            const containerWidth = containerRect.width - 80;
            const containerHeight = containerRect.height - 80;
            const thumbnailSize = 160;
            
            clustersData.forEach((cluster, index) => {
                const thumbnail = document.createElement('div');
                thumbnail.className = 'floating-thumbnail';
                
                const cols = Math.min(3, clustersData.length);
                const rows = Math.ceil(clustersData.length / cols);
                const col = index % cols;
                const row = Math.floor(index / cols);
                
                const usableWidth = containerWidth - 160;
                const usableHeight = containerHeight - 160;
                const cellWidth = usableWidth / cols;
                const cellHeight = usableHeight / rows;
                
                const gridStartX = (containerWidth - (cols * cellWidth)) / 2 + 80;
                const gridStartY = (containerHeight - (rows * cellHeight)) / 2 + 80;
                
                let x = gridStartX + (col * cellWidth) + (cellWidth / 2);
                let y = gridStartY + (row * cellHeight) + (cellHeight / 2);
                
                x += (Math.random() - 0.5) * Math.min(cellWidth * 0.3, 60);
                y += (Math.random() - 0.5) * Math.min(cellHeight * 0.3, 60);
                
                x = Math.max(thumbnailSize/2 + 40, Math.min(x, containerWidth - thumbnailSize/2 + 40));
                y = Math.max(thumbnailSize/2 + 40, Math.min(y, containerHeight - thumbnailSize/2 + 40));
                
                thumbnail.style.left = (x - thumbnailSize/2) + 'px';
                thumbnail.style.top = (y - thumbnailSize/2) + 'px';
                
                if (cluster.image && cluster.image.trim() !== '') {
                    const img = document.createElement('img');
                    img.src = cluster.image;
                    img.alt = cluster.title;
                    img.onerror = () => {
                        thumbnail.innerHTML = `<div class="thumbnail-fallback">${cluster.title}</div>`;
                    };
                    thumbnail.appendChild(img);
                } else {
                    const fallback = document.createElement('div');
                    fallback.className = 'thumbnail-fallback';
                    fallback.textContent = cluster.title;
                    thumbnail.appendChild(fallback);
                }
                
                thumbnail.addEventListener('click', () => {
                    this.openClusterModal(index);
                });
                
                container.appendChild(thumbnail);
            });
        }

        startFloatingAnimation() {
            const thumbnails = document.querySelectorAll('.floating-thumbnail');
            const container = document.getElementById('thumbnails-container');
            if (!container || thumbnails.length === 0) return;
            
            this.physicsObjects = Array.from(thumbnails).map((thumbnail, index) => {
                return {
                    element: thumbnail,
                    x: parseFloat(thumbnail.style.left) + 80,
                    y: parseFloat(thumbnail.style.top) + 80,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    radius: 80,
                    mass: 1,
                    id: index
                };
            });
            
            this.containerBounds = {
                left: 0,
                top: 0,
                right: container.clientWidth,
                bottom: container.clientHeight
            };
            
            this.startPhysicsLoop();
        }

        startPhysicsLoop() {
            if (this.animationRunning) return;
            this.animationRunning = true;
            const animate = () => {
                if (!this.animationRunning) return;
                this.updatePhysics();
                this.renderThumbnails();
                requestAnimationFrame(animate);
            };
            animate();
        }

        updatePhysics() {
            if (!this.physicsObjects) return;
            this.physicsObjects.forEach(obj => {
                obj.x += obj.vx;
                obj.y += obj.vy;
                
                if (obj.x - obj.radius <= this.containerBounds.left || 
                    obj.x + obj.radius >= this.containerBounds.right) {
                    obj.vx *= -0.8;
                    obj.x = Math.max(obj.radius, Math.min(this.containerBounds.right - obj.radius, obj.x));
                }
                
                if (obj.y - obj.radius <= this.containerBounds.top || 
                    obj.y + obj.radius >= this.containerBounds.bottom) {
                    obj.vy *= -0.8;
                    obj.y = Math.max(obj.radius, Math.min(this.containerBounds.bottom - obj.radius, obj.y));
                }
                
                const maxSpeed = 3;
                const speed = Math.sqrt(obj.vx * obj.vx + obj.vy * obj.vy);
                if (speed > maxSpeed) {
                    obj.vx = (obj.vx / speed) * maxSpeed;
                    obj.vy = (obj.vy / speed) * maxSpeed;
                }
            });
            
            for (let i = 0; i < this.physicsObjects.length; i++) {
                for (let j = i + 1; j < this.physicsObjects.length; j++) {
                    this.handleCollision(this.physicsObjects[i], this.physicsObjects[j]);
                }
            }
        }

        handleCollision(obj1, obj2) {
            const dx = obj2.x - obj1.x;
            const dy = obj2.y - obj1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const minDistance = obj1.radius + obj2.radius;
            
            if (distance < minDistance) {
                const overlap = minDistance - distance;
                const separationX = (dx / distance) * (overlap / 2);
                const separationY = (dy / distance) * (overlap / 2);
                
                obj1.x -= separationX;
                obj1.y -= separationY;
                obj2.x += separationX;
                obj2.y += separationY;
                
                const normalX = dx / distance;
                const normalY = dy / distance;
                const relativeVelocityX = obj2.vx - obj1.vx;
                const relativeVelocityY = obj2.vy - obj1.vy;
                const velocityAlongNormal = relativeVelocityX * normalX + relativeVelocityY * normalY;
                
                if (velocityAlongNormal > 0) return;
                
                const restitution = 0.6;
                const impulse = -(1 + restitution) * velocityAlongNormal;
                const impulseX = impulse * normalX;
                const impulseY = impulse * normalY;
                
                obj1.vx -= impulseX * 0.5;
                obj1.vy -= impulseY * 0.5;
                obj2.vx += impulseX * 0.5;
                obj2.vy += impulseY * 0.5;
            }
        }

        renderThumbnails() {
            if (!this.physicsObjects) return;
            this.physicsObjects.forEach(obj => {
                obj.element.style.left = (obj.x - obj.radius) + 'px';
                obj.element.style.top = (obj.y - obj.radius) + 'px';
            });
        }

        setupEventListeners() {
            const closeModal = document.getElementById('close-modal');
            if (closeModal) {
                closeModal.addEventListener('click', () => this.closeClusterModal());
            }

            const toggleInfo = document.getElementById('toggle-info');
            const modalHeader = document.getElementById('modal-header');
            if (toggleInfo && modalHeader) {
                toggleInfo.addEventListener('click', () => {
                    modalHeader.classList.toggle('collapsed');
                    toggleInfo.textContent = modalHeader.classList.contains('collapsed') ? 'Show Info' : 'Hide Info';
                });
            }

            const closeDetail = document.getElementById('close-detail');
            if (closeDetail) {
                closeDetail.addEventListener('click', () => this.closeCapacityDetail());
            }

            const modal = document.getElementById('cluster-modal');
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target.id === 'cluster-modal') {
                        this.closeClusterModal();
                    }
                });
            }

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    const capacityDetail = document.getElementById('capacity-detail');
                    const clusterModal = document.getElementById('cluster-modal');
                    
                    if (capacityDetail && capacityDetail.classList.contains('active')) {
                        this.closeCapacityDetail();
                    } else if (clusterModal && clusterModal.classList.contains('active')) {
                        this.closeClusterModal();
                    }
                }
            });

            window.addEventListener('resize', () => {
                if (this.currentCluster !== null) {
                    this.updateNetworkDimensions();
                    this.drawNetwork();
                }
                this.updateContainerBounds();
                setTimeout(() => {
                    this.animationRunning = false;
                    this.createFloatingThumbnails();
                    this.startFloatingAnimation();
                }, 100);
            });
        }

        openClusterModal(clusterId) {
            this.currentCluster = clusterId;
            const cluster = clustersData[clusterId];
            
            document.getElementById('modal-title').textContent = cluster.title;
            document.getElementById('modal-description').textContent = cluster.description;
            
            const whyMatters = document.getElementById('why-matters');
            if (cluster.why_matters && cluster.why_matters.trim() !== '') {
                whyMatters.innerHTML = `<h4>Why This Cluster Matters:</h4><p>${cluster.why_matters}</p>`;
                whyMatters.style.display = 'block';
            } else {
                whyMatters.style.display = 'none';
            }
            
            const modalHeader = document.getElementById('modal-header');
            const toggleInfo = document.getElementById('toggle-info');
            if (modalHeader && toggleInfo) {
                modalHeader.classList.remove('collapsed');
                toggleInfo.textContent = 'Hide Info';
            }
            
            document.getElementById('cluster-modal').classList.add('active');
            
            setTimeout(() => {
                this.updateNetworkDimensions();
                this.drawNetwork();
            }, 100);
        }

        closeClusterModal() {
            const modal = document.getElementById('cluster-modal');
            if (modal) {
                modal.classList.remove('active');
            }
            this.closeCapacityDetail();
            this.currentCluster = null;
            if (this.simulation) {
                this.simulation.stop();
            }
            this.svg.selectAll("*").remove();
        }

        updateNetworkDimensions() {
            const container = document.querySelector('.network-container');
            if (container) {
                this.width = container.clientWidth;
                this.height = container.clientHeight;
                this.svg.attr('width', this.width).attr('height', this.height);
            }
        }

        drawNetwork() {
            if (this.currentCluster === null || !clustersData[this.currentCluster]) return;
            
            const cluster = clustersData[this.currentCluster];
            this.svg.selectAll("*").remove();

            const defs = this.svg.append('defs');
            const centralGradient = defs.append('radialGradient').attr('id', 'centralGradient');
            centralGradient.append('stop').attr('offset', '0%').attr('stop-color', '#a855f7').attr('stop-opacity', 0.8);
            centralGradient.append('stop').attr('offset', '100%').attr('stop-color', '#1e293b').attr('stop-opacity', 0.9);

            const nodes = [{
                id: 'center',
                title: cluster.title,
                type: 'cluster',
                x: this.width / 2,
                y: this.height / 2,
                fx: this.width / 2,
                fy: this.height / 2
            }];

            const links = [];

            if (cluster.capacities && cluster.capacities.length > 0) {
                cluster.capacities.forEach((capacity, index) => {
                    const nodeId = `capacity-${index}`;
                    nodes.push({
                        id: nodeId,
                        title: capacity.title,
                        subtitle: capacity.subtitle,
                        type: 'capacity',
                        capacity: capacity,
                        color: capacity.color || "rgb(139, 92, 246)"
                    });
                    links.push({ source: 'center', target: nodeId });
                });
            }

            this.simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(150))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(this.width / 2, this.height / 2))
                .force('collision', d3.forceCollide().radius(60));

            const link = this.svg.append('g').selectAll('path').data(links).enter().append('path')
                .attr('stroke', '#8b5cf6').attr('stroke-width', 2).attr('opacity', 0.6).attr('fill', 'none');

            const node = this.svg.append('g').selectAll('g').data(nodes).enter().append('g')
                .call(d3.drag().on('start', this.dragstarted.bind(this)).on('drag', this.dragged.bind(this)).on('end', this.dragended.bind(this)));

            node.filter(d => d.type === 'cluster').append('circle')
                .attr('r', 50).attr('fill', 'url(#centralGradient)').attr('stroke', '#a855f7').attr('stroke-width', 3);

            node.filter(d => d.type === 'cluster').append('text')
                .attr('text-anchor', 'middle').attr('dy', '.35em').attr('fill', '#ffffff')
                .attr('font-weight', 'bold').attr('font-size', '12px').text(d => d.title);

            const capacityNodes = node.filter(d => d.type === 'capacity');

            capacityNodes.append('circle').attr('r', 35).attr('fill', d => d.color)
                .attr('stroke', '#ffffff').attr('stroke-width', 2).attr('opacity', 0.8).style('cursor', 'pointer')
                .on('mouseover', function() { d3.select(this).transition().duration(200).attr('r', 38); })
                .on('mouseout', function() { d3.select(this).transition().duration(200).attr('r', 35); });

            capacityNodes.append('text').attr('text-anchor', 'middle').attr('dy', '-5')
                .attr('fill', '#ffffff').attr('font-weight', 'bold').attr('font-size', '10px').style('cursor', 'pointer')
                .text(d => d.title && d.title.length > 12 ? d.title.substring(0, 12) + '...' : d.title || '');

            capacityNodes.append('text').attr('text-anchor', 'middle').attr('dy', '8')
                .attr('fill', '#ffffff').attr('font-size', '8px').attr('opacity', 0.8).style('cursor', 'pointer')
                .text(d => d.subtitle && d.subtitle.length > 15 ? d.subtitle.substring(0, 15) + '...' : d.subtitle || '');

            capacityNodes.on('click', (event, d) => {
                if (d.type === 'capacity') {
                    this.openCapacityDetail(d.capacity);
                }
            });

            this.simulation.on('tick', () => {
                link.attr('d', d => {
                    const dx = d.target.x - d.source.x;
                    const dy = d.target.y - d.source.y;
                    const dr = Math.sqrt(dx * dx + dy * dy) * 0.3;
                    return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
                });
                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });
        }

        openCapacityDetail(capacity) {
            if (!capacity) return;
            document.getElementById('capacity-title').textContent = capacity.title || '';
            document.getElementById('capacity-subtitle').textContent = capacity.subtitle || '';
            document.getElementById('capacity-what-it-is').innerHTML = this.parseMarkdown(capacity.what_it_is || '');
            document.getElementById('capacity-why-exiled').innerHTML = this.parseMarkdown(capacity.why_exiled || '');
            document.getElementById('capacity-what-possible').innerHTML = this.parseMarkdown(capacity.what_possible || '');

            const distortionsList = document.getElementById('capacity-distortions');
            distortionsList.innerHTML = '';
            
            if (capacity.distortions && capacity.distortions.length > 0) {
                capacity.distortions.forEach(distortion => {
                    const li = document.createElement('li');
                    li.className = 'distortion-item';
                    li.innerHTML = `
                        <div class="distortion-name">${distortion.name || ''}</div>
                        <div class="distortion-description">${distortion.description || ''}</div>
                    `;
                    distortionsList.appendChild(li);
                });
            }
            document.getElementById('capacity-detail').classList.add('active');
        }

        closeCapacityDetail() {
            const detail = document.getElementById('capacity-detail');
            if (detail) {
                detail.classList.remove('active');
            }
        }

        parseMarkdown(text) {
            if (!text) return '';
            return text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/\n/g, '<br>');
        }

        dragstarted(event, d) {
            if (!event.active) this.simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        dragended(event, d) {
            if (!event.active) this.simulation.alphaTarget(0);
            if (d.type !== 'cluster') {
                d.fx = null;
                d.fy = null;
            }
        }

        updateContainerBounds() {
            const container = document.getElementById('thumbnails-container');
            if (container) {
                this.containerBounds = {
                    left: 0,
                    top: 0,
                    right: container.clientWidth,
                    bottom: container.clientHeight
                };
            }
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        new CapacitiesVisualization();
    });
</script>
{{ end }}